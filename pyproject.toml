[project]
name = "linux-benchmark-lib"
version = "0.66.3"
description = "A robust and configurable Python library for benchmarking Linux computational node performance"
readme = "README.md"
requires-python = ">=3.12"
authors = [
    { name = "Your Name", email = "your.email@example.com" }
]
dependencies = [
    "psutil>=7.0.0",
    "pandas>=2.0.0",
    "numpy>=1.24.0",
    "jc>=1.25.0",
    "PyYAML>=6.0",
    "pydantic>=2.0.0", # Added pydantic
    "structlog>=24.2.0",
    "plyer>=2.1.0",
    "pystray>=0.19.5",
    "pillow>=12.0.0",
    "desktop-notifier>=6.2.0",
]

[project.optional-dependencies]
dfaas = [
    "fabric>=3.2.2",
    "invoke>=2.2.1",
]
peva_faas = [
    "duckdb>=1.1.0",
    "pyarrow>=17.0.0",
]
ui = [
    "rich>=13.7.0",
    "typer>=0.12.5",
    "rapidfuzz>=3.0.0",
    "prompt_toolkit>=3.0.0",
]
controller = [
    "ansible-runner>=2.4.0",
    "ansible-core>=2.15.0",
    "matplotlib>=3.7.0",
    "seaborn>=0.12.0",
]
dev = [
    "rich>=13.7.0",
    "typer>=0.12.5",
    "rapidfuzz>=3.0.0",
    "prompt_toolkit>=3.0.0",
    "PySide6>=6.6.0",
    "pytest-cov>=4.1.0",
    "vulture>=2.10",
    "molecule>=6",
    "molecule-plugins[delegated]",
    "ansible-core>=2.15.0",
    "flake8-cognitive-complexity>=0.1.0",
]
docs = [
    "mkdocs>=1.6",
    "mkdocs-material>=9.5",
    "mkdocstrings[python]>=0.26",
    "rich>=13.7.0",
    "typer>=0.12.5",
    "rapidfuzz>=3.0.0",
    "prompt_toolkit>=3.0.0",
]
gui = [
    "PySide6>=6.6.0",
]


[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[tool.setuptools.packages.find]
include = ["lb_runner*", "lb_controller*", "lb_ui*", "lb_gui*", "lb_analytics*", "lb_provisioner*", "lb_app*", "lb_common*", "lb_plugins*"]
exclude = ["reports*", "data_exports*", "benchmark_results*", "tests*"]

[tool.setuptools.package-data]
lb_plugins = [
    "plugins/**/*",
]
lb_controller = [
    "ansible/**/*",
]
lb_provisioner = [
    "assets/**/*",
]
lb_gui = [
    "resources/**/*",
]

[project.scripts]
lb = "lb_ui.cli.main:main"
lb-ui = "lb_ui.cli.main:main"
lb-gui = "lb_gui.main:main"

[project.entry-points."linux_benchmark.collectors"]
psutil = "lb_runner.metric_collectors.builtin:PSUTIL_COLLECTOR"
cli = "lb_runner.metric_collectors.builtin:CLI_COLLECTOR"

[project.entry-points."linux_benchmark.workloads"]
stress_ng = "lb_plugins.plugins.stress_ng.plugin:PLUGIN"
fio = "lb_plugins.plugins.fio.plugin:PLUGIN"
dd = "lb_plugins.plugins.dd.plugin:PLUGIN"
hpl = "lb_plugins.plugins.hpl.plugin:PLUGIN"
stream = "lb_plugins.plugins.stream.plugin:PLUGIN"

[tool.uv]
package = true

[tool.black]
line-length = 88
target-version = ['py312']
include = '\.pyi?$'
exclude = '''
/(
    \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | _build
  | buck-out
  | build
  | dist
)/
'''

[tool.pytest.ini_options]
minversion = "7.0"
addopts = "-ra -q --strict-markers"
testpaths = ["tests"]
markers = [
    # Test levels
    "unit: all unit tests (fast, isolated)",
    "integration: integration tests (service-level)",
    "e2e: end-to-end tests (full stack)",

    # Module-specific unit markers
    "unit_runner: tests for the lb_runner package (execution, local logic)",
    "unit_controller: tests for the lb_controller package (orchestration, state)",
    "unit_ui: tests for the User Interface (CLI commands, TUI, prompts)",
    "unit_provisioner: tests for provisioning logic (Multipass, Docker)",
    "unit_analytics: tests for lb_analytics (data processing, reporting)",
    "unit_plugins: unit tests specific to workload plugins",
    "unit_baseline: unit tests for the baseline workload plugin",
    "unit_common: tests for lb_common utilities",

    # Integration markers (legacy naming)
    "inter_generic: marks tests as integration tests (deselect with '-m \"not inter_generic\"')",
    "inter_docker: integration tests that build/run plugin Docker images",
    "inter_multipass: integration tests that validate plugin multipass/ansible assets",
    "inter_multipass_single: multipass e2e per-workload runs with artifact checks",
    "inter_e2e: full end-to-end tests (e.g., with real VMs)",
    "inter_plugins: integration tests specific to workload plugins",
    "inter_baseline: integration tests for the baseline workload plugin",

    # Performance markers
    "slow: tests that require > 1 second",
    "slowest: very slow tests (minutes) such as VM provisioning",
]
python_files = "test_*.py"
python_classes = "Test*"
python_functions = "test_*"

[tool.mypy]
python_version = "3.12"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true
exclude = "^molecule/"

[tool.pydocstyle]
inherit = false
ignore = "D100,D104,D203,D213"
match-dir = "(?!tests).*"

[dependency-groups]
dev = [
    "pytest>=7.3.0",
    "pytest-cov>=4.0.0",
    "pytest-mock>=3.10.0",
    "psutil>=7.0.0",
    "rich>=13.7.0",
    "typer>=0.12.5",
    "rapidfuzz>=3.0.0",
    "prompt_toolkit>=3.0.0",
    "PySide6>=6.6.0",
    "black>=23.0.0",
    "flake8>=6.0.0",
    "flake8-tidy-imports>=4.12.0",
    "pydocstyle>=6.3.0",
    "mypy>=1.0.0",
    "pre-commit>=3.2.0",
    "ansible-runner>=2.4.0",
    "vulture>=2.10",
    "flake8-cognitive-complexity>=0.1.0",
    "ruff>=0.14.10",
    "coverage>=7.13.0",
    "radon>=6.0.1",
    "xenon>=0.9.3",
    "lizard>=1.19.0",
    "grimp>=3.14",
    "import-linter>=2.9",
    "pydeps>=3.0.1",
    "pyan3>=1.2.0",
    "deptry>=0.24.0",
    "pip-audit>=2.9.0",
    "bandit>=1.9.2",
    "semgrep>=1.86.0",
    "tenacity>=9.1.2",
]

[tool.deptry]
extend_exclude = ["molecule"]
per_rule_ignores = { DEP001 = ["controller_stop_runner"], DEP002 = ["pytest-cov", "vulture", "molecule", "molecule-plugins", "flake8-cognitive-complexity", "mkdocs", "mkdocs-material", "mkdocstrings"] }

# =============================================================================
# Import Linter - Enforces layered architecture import boundaries
# =============================================================================
# Run with: uv run lint-imports
#
# Architecture:
#   lb_common (base) <- lb_plugins <- lb_runner <- lb_controller <- lb_app <- lb_ui
#   lb_analytics and lb_provisioner are siblings at the lb_app level
#
# These contracts enforce that packages only import from allowed lower layers.
# The .api boundary enforcement is handled by scripts/check_api_imports.py
# because import-linter tracks transitive imports which don't work well with
# re-exports from .api modules.

[tool.importlinter]
root_packages = ["lb_common", "lb_plugins", "lb_runner", "lb_controller", "lb_app", "lb_ui", "lb_gui", "lb_analytics", "lb_provisioner"]
include_external_packages = false

# Layered architecture contract - enforces the dependency hierarchy
# Note: lb_controller, lb_analytics, lb_provisioner are at the same level (can't import each other)
[[tool.importlinter.contracts]]
name = "Layered architecture"
type = "layers"
layers = [
    "lb_ui : lb_gui",
    "lb_app",
    "lb_controller",
    "lb_runner",
    "lb_plugins",
    "lb_common",
]
# lb_plugins has a known dependency on lb_runner for log_manager services
# This is a design decision to allow plugins to use runner's logging facilities
ignore_imports = [
    "lb_plugins.plugins.dfaas.services.log_manager -> lb_runner.api",
    "lb_plugins.plugins.peva_faas.services.log_manager -> lb_runner.api",
]

# lb_analytics is isolated - only imports from lb_common
[[tool.importlinter.contracts]]
name = "lb_analytics isolation"
type = "forbidden"
source_modules = ["lb_analytics"]
forbidden_modules = ["lb_plugins", "lb_runner", "lb_controller", "lb_app", "lb_ui", "lb_gui", "lb_provisioner"]

# lb_provisioner can only import from lb_common and lb_plugins
[[tool.importlinter.contracts]]
name = "lb_provisioner layer restrictions"
type = "forbidden"
source_modules = ["lb_provisioner"]
forbidden_modules = ["lb_runner", "lb_controller", "lb_app", "lb_ui", "lb_gui", "lb_analytics"]

# Note: The "forbidden" contract type tracks transitive imports, which is not what
# we want for the .api boundary check. Use scripts/check_api_imports.py for that.
# The layers contract above handles the main architecture hierarchy.
