"""
Generate plugin-dependent assets for Docker and Ansible from manifest files.

Usage:
    uv run python tools/gen_plugin_assets.py

This script reads plugin manifests from plugins/manifests/*.yaml and writes:
- Dockerfile: updates the generated package installation block.
- ansible/roles/workload_runner/tasks/plugins.generated.yml: installs plugin deps.
"""

from __future__ import annotations

import argparse
import dataclasses
import sys
from pathlib import Path
from typing import Iterable, List, Sequence

import yaml


ROOT = Path(__file__).resolve().parent.parent
MANIFEST_DIR = ROOT / "plugins" / "manifests"
DOCKERFILE_PATH = ROOT / "Dockerfile"
ANSIBLE_TASKS_PATH = ROOT / "ansible" / "roles" / "workload_runner" / "tasks" / "plugins.generated.yml"

DOCKER_START = "# BEGIN GENERATED PLUGIN PACKAGES"
DOCKER_END = "# END GENERATED PLUGIN PACKAGES"

# Base packages we always install regardless of plugin set
BASE_APT_PACKAGES = ["git", "procps", "sysstat"]


@dataclasses.dataclass
class PluginManifest:
    """Minimal manifest describing dependency needs for a workload plugin."""

    name: str
    apt_packages: List[str]
    pip_packages: List[str]

    @classmethod
    def from_dict(cls, data: dict) -> "PluginManifest":
        name = data.get("name")
        if not name:
            raise ValueError("Manifest missing required 'name'")
        apt = data.get("apt_packages") or []
        pip = data.get("pip_packages") or []
        if not isinstance(apt, list) or not isinstance(pip, list):
            raise ValueError(f"Manifest {name} has invalid package lists")
        return cls(name=name, apt_packages=apt, pip_packages=pip)


def load_manifests() -> List[PluginManifest]:
    """Load all manifests from the manifest directory."""
    manifests: List[PluginManifest] = []
    for path in sorted(MANIFEST_DIR.glob("*.yaml")):
        with path.open() as fh:
            data = yaml.safe_load(fh) or {}
        manifests.append(PluginManifest.from_dict(data))
    if not manifests:
        raise RuntimeError(f"No manifests found under {MANIFEST_DIR}")
    return manifests


def render_docker_block(apt_packages: Sequence[str], pip_packages: Sequence[str]) -> str:
    """Render the generated Dockerfile block."""
    lines: List[str] = [
        "# This section is auto-generated by tools/gen_plugin_assets.py; do not edit manually.",
    ]
    install_lines = ["RUN apt-get update && apt-get install -y \\"]
    for pkg in apt_packages:
        install_lines.append(f"    {pkg} \\")
    install_lines.append("    --no-install-recommends && \\")
    install_lines.append("    rm -rf /var/lib/apt/lists/*")
    lines.extend(install_lines)

    if pip_packages:
        lines.append(
            "RUN --mount=type=cache,target=/root/.cache/uv \\"
        )
        pip_list = " ".join(sorted(pip_packages))
        lines.append(f"    uv pip install -U {pip_list}")

    return "\n".join(lines)


def replace_block(path: Path, start: str, end: str, block: str) -> None:
    """Replace the section between start/end markers in a file."""
    content = path.read_text().splitlines()
    if start not in content or end not in content:
        raise RuntimeError(f"Markers not found in {path}")

    start_idx = content.index(start) + 1
    end_idx = content.index(end)
    new_lines = content[:start_idx] + block.splitlines() + content[end_idx:]
    path.write_text("\n".join(new_lines) + "\n")


def render_ansible_tasks(apt_packages: Sequence[str], pip_packages: Sequence[str]) -> str:
    """Render the generated Ansible tasks for plugin dependencies."""
    lines: List[str] = [
        "# This file is auto-generated by tools/gen_plugin_assets.py; do not edit manually.",
    ]
    if apt_packages:
        lines.extend(
            [
                "- name: Install workload plugin system packages",
                "  ansible.builtin.package:",
                "    name:",
            ]
        )
        lines.extend([f"      - {pkg}" for pkg in apt_packages])
        lines.extend(
            [
                "    state: present",
                "    update_cache: true",
            ]
        )

    if pip_packages:
        if apt_packages:
            lines.append("")
        lines.extend(
            [
                "- name: Install workload plugin pip packages",
                "  ansible.builtin.pip:",
                "    name:",
            ]
        )
        lines.extend([f"      - {pkg}" for pkg in pip_packages])
        lines.extend(
            [
                "    executable: pip3",
            ]
        )

    return "\n".join(lines) + "\n"


def unique(seq: Iterable[str]) -> List[str]:
    """Return sorted unique entries."""
    return sorted(set(seq))


def generate() -> None:
    """Generate Docker and Ansible assets from manifests."""
    manifests = load_manifests()

    apt_packages: List[str] = []
    pip_packages: List[str] = []
    for manifest in manifests:
        apt_packages.extend(manifest.apt_packages)
        pip_packages.extend(manifest.pip_packages)

    apt_packages = unique(BASE_APT_PACKAGES + apt_packages)
    pip_packages = unique(pip_packages)

    docker_block = render_docker_block(apt_packages, pip_packages)
    replace_block(DOCKERFILE_PATH, DOCKER_START, DOCKER_END, docker_block)

    ansible_tasks = render_ansible_tasks(apt_packages, pip_packages)
    ANSIBLE_TASKS_PATH.write_text(ansible_tasks)


def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Generate plugin assets from manifests.")
    parser.parse_args(argv)
    generate()
    return 0


if __name__ == "__main__":
    sys.exit(main())
