"""
Generate plugin-dependent assets for Docker and Ansible.

Usage:
    uv run python tools/gen_plugin_assets.py

This script queries the PluginRegistry (built-in + user plugins) and reads legacy manifests 
to generate:
- Dockerfile: updates the generated package installation block.
- ansible/roles/workload_runner/tasks/plugins.generated.yml: installs plugin deps.
"""

from __future__ import annotations

import argparse
import dataclasses
import sys
from pathlib import Path
from typing import Iterable, List, Sequence

import yaml

# Add project root to sys.path to allow imports
ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(ROOT))

from plugins.registry import PluginRegistry, USER_PLUGIN_DIR
from plugins.interface import WorkloadPlugin

MANIFEST_DIR = ROOT / "plugins" / "manifests"
DOCKERFILE_PATH = ROOT / "Dockerfile"
ANSIBLE_TASKS_PATH = ROOT / "ansible" / "roles" / "workload_runner" / "tasks" / "plugins.generated.yml"

DOCKER_START = "# BEGIN GENERATED PLUGIN PACKAGES"
DOCKER_END = "# END GENERATED PLUGIN PACKAGES"

# Base packages we always install regardless of plugin set
BASE_APT_PACKAGES = ["git", "procps", "sysstat"]


@dataclasses.dataclass
class PluginDependencies:
    """Dependencies for a workload plugin."""
    name: str
    apt_packages: List[str]
    pip_packages: List[str]


def load_legacy_manifests() -> List[PluginDependencies]:
    """Load legacy manifests from the source manifest directory."""
    deps: List[PluginDependencies] = []
    if MANIFEST_DIR.exists():
        for path in sorted(MANIFEST_DIR.glob("*.yaml")):
            try:
                with path.open() as fh:
                    data = yaml.safe_load(fh) or {}
                    name = data.get("name")
                    if name:
                        deps.append(PluginDependencies(
                            name=name,
                            apt_packages=data.get("apt_packages") or [],
                            pip_packages=data.get("pip_packages") or []
                        ))
            except Exception as e:
                print(f"Warning: Failed to parse manifest {path}: {e}")
    return deps

def load_user_manifests() -> List[PluginDependencies]:
    """Load manifests from the user config directory."""
    deps: List[PluginDependencies] = []
    if USER_PLUGIN_DIR.exists():
        for path in sorted(USER_PLUGIN_DIR.glob("*.yaml")):
            try:
                with path.open() as fh:
                    data = yaml.safe_load(fh) or {}
                    name = data.get("name")
                    if name:
                        deps.append(PluginDependencies(
                            name=name,
                            apt_packages=data.get("apt_packages") or [],
                            pip_packages=data.get("pip_packages") or []
                        ))
            except Exception as e:
                print(f"Warning: Failed to parse user manifest {path}: {e}")
    return deps

def load_registry_dependencies() -> List[PluginDependencies]:
    """Query the PluginRegistry for dependencies defined in Python code."""
    # We need to create the registry, which loads built-ins and user plugins
    # We import builtin_plugins here to register them manually if needed,
    # but PluginRegistry does entry points and user plugins automatically.
    # For built-ins, we need to make sure they are registered.
    from plugins.builtin import builtin_plugins
    
    registry = PluginRegistry(plugins=builtin_plugins())
    
    deps: List[PluginDependencies] = []
    for name, plugin in registry.available().items():
        apt = []
        pip = []
        
        # Check if it's a new-style plugin with get_required_* methods
        if isinstance(plugin, WorkloadPlugin):
            apt = plugin.get_required_apt_packages()
            pip = plugin.get_required_pip_packages()
            
        if apt or pip:
            deps.append(PluginDependencies(name=name, apt_packages=apt, pip_packages=pip))
            
    return deps


def render_docker_block(apt_packages: Sequence[str], pip_packages: Sequence[str]) -> str:
    """Render the generated Dockerfile block."""
    lines: List[str] = [
        "# This section is auto-generated by tools/gen_plugin_assets.py; do not edit manually.",
    ]
    install_lines = ["RUN apt-get update && apt-get install -y \\"]
    for pkg in apt_packages:
        install_lines.append(f"    {pkg} \\")
    install_lines.append("    --no-install-recommends && \\")
    install_lines.append("    rm -rf /var/lib/apt/lists/*")
    lines.extend(install_lines)

    if pip_packages:
        lines.append("RUN --mount=type=cache,target=/root/.cache/uv \\")
        pip_list = " ".join(sorted(pip_packages))
        lines.append(f"    uv pip install -U {pip_list}")

    return "\n".join(lines)


def replace_block(path: Path, start: str, end: str, block: str) -> None:
    """Replace the section between start/end markers in a file."""
    content = path.read_text().splitlines()
    if start not in content or end not in content:
        raise RuntimeError(f"Markers not found in {path}")

    start_idx = content.index(start) + 1
    end_idx = content.index(end)
    new_lines = content[:start_idx] + block.splitlines() + content[end_idx:]
    path.write_text("\n".join(new_lines) + "\n")


def unique(seq: Iterable[str]) -> List[str]:
    """Return sorted unique entries."""
    return sorted(set(seq))


def generate() -> None:
    """Generate Docker assets from manifests."""
    
    # Collect all dependencies from all sources
    all_deps = []
    all_deps.extend(load_legacy_manifests())
    all_deps.extend(load_user_manifests())
    all_deps.extend(load_registry_dependencies())

    apt_packages: List[str] = []
    pip_packages: List[str] = []
    
    for dep in all_deps:
        apt_packages.extend(dep.apt_packages)
        pip_packages.extend(dep.pip_packages)

    apt_packages = unique(BASE_APT_PACKAGES + apt_packages)
    pip_packages = unique(pip_packages)

    print(f"Generating assets for {len(all_deps)} plugin source(s)...")
    print(f"APT packages: {len(apt_packages)}")
    print(f"PIP packages: {len(pip_packages)}")

    docker_block = render_docker_block(apt_packages, pip_packages)
    replace_block(DOCKERFILE_PATH, DOCKER_START, DOCKER_END, docker_block)


def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Generate plugin assets from manifests and registry.")
    parser.parse_args(argv)
    generate()
    return 0


if __name__ == "__main__":
    sys.exit(main())
