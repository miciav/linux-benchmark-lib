- name: Set workload repetition context
  ansible.builtin.set_fact:
    workload_runner_current_workload: "{{ workload_item[0] }}"
    workload_runner_current_rep: "{{ workload_item[1] | int }}"
    workload_runner_total_reps: >-
      {{
        (workload_runner_reps | length)
        if workload_runner_reps is defined and (workload_runner_reps | length) > 0
        else (workload_runner_repetitions_total | default(1) | int)
      }}
    run_prefix: "[run:{{ workload_item[0] }}]"

- name: "{{ run_prefix }} Emit start event for repetition"
  ansible.builtin.debug:
    msg: >-
      LB_EVENT {{
        {
          "run_id": run_id | default(""),
          "host": inventory_hostname,
          "workload": workload_runner_current_workload,
          "repetition": workload_runner_current_rep,
          "total_repetitions": workload_runner_total_reps,
          "status": "running"
        } | to_json
      }}

- name: "{{ run_prefix }} Initialize event stream files"
  ansible.builtin.shell:
    cmd: |
      set -euo pipefail
      log_file="{{ workload_runner_output_dir | default('/tmp') }}/lb_events.stream.log"
      offset_file="{{ workload_runner_output_dir | default('/tmp') }}/lb_events.offset"
      mkdir -p "$(dirname "$log_file")"
      touch "$log_file"
      bytes="$(wc -c < "$log_file" | tr -d ' ')"
      printf '%s' "$bytes" > "$offset_file"
  args:
    chdir: "{{ workload_runner_workdir }}"
    executable: /bin/bash
  changed_when: false

- name: Run workload repetition via LocalRunner
  block:
    - name: "{{ run_prefix }} Clean up previous run artifacts"
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - "{{ workload_runner_workdir }}/STOP"
        - "{{ workload_runner_workdir }}/lb_localrunner.status.json"
        - "{{ workload_runner_workdir }}/lb_localrunner.pid"
        - "{{ workload_runner_workdir }}/lb_poll_start.time"

    - name: "{{ run_prefix }} Execute {{ workload_runner_current_workload }} repetition {{ workload_runner_current_rep }}"
      ansible.builtin.command: >
        {{ workload_runner_uv_bin }} run python -m lb_runner.services.async_localrunner
      args:
        chdir: "{{ workload_runner_workdir }}"
      environment:
        LB_RUN_HOST: "{{ inventory_hostname }}"
        LB_RUN_HOST_ADDRESS: "{{ ansible_host | default(inventory_hostname) }}"
        LB_RUN_WORKLOAD: "{{ workload_runner_current_workload }}"
        LB_RUN_REPETITION: "{{ workload_runner_current_rep }}"
        LB_RUN_TOTAL_REPS: "{{ workload_runner_total_reps }}"
        LB_RUN_ID: "{{ run_id }}"
        LB_RUN_STOP_FILE: "{{ workload_runner_workdir }}/STOP"
        LB_BENCH_CONFIG_PATH: "{{ workload_runner_workdir }}/benchmark_config.generated.json"
        LB_EVENT_STREAM_PATH: "{{ workload_runner_output_dir | default('/tmp') }}/lb_events.stream.log"
        LB_ENABLE_EVENT_LOGGING: "1"
        LB_LOG_LEVEL: "INFO"
        LB_RUN_DAEMONIZE: "1"
        LB_RUN_PID_PATH: "{{ workload_runner_workdir }}/lb_localrunner.pid"
        LB_RUN_STATUS_PATH: "{{ workload_runner_workdir }}/lb_localrunner.status.json"
        LB_LOKI_ENABLED: "{{ (workload_runner_config.loki.enabled | default(false)) | ternary('1', '0') }}"
        LB_LOKI_ENDPOINT: "{{ workload_runner_config.loki.endpoint | default('') }}"
      register: workload_runner_async
      changed_when: true
      async: 45
      poll: 0

    - name: "{{ run_prefix }} Wait for LocalRunner pid file"
      ansible.builtin.wait_for:
        path: "{{ workload_runner_workdir }}/lb_localrunner.pid"
        state: present
        timeout: 10

    - name: "{{ run_prefix }} Initialize polling status"
      ansible.builtin.set_fact:
        workload_runner_finished: false

    - name: "{{ run_prefix }} Stream LB_EVENT lines (recursive polling)"
      ansible.builtin.include_tasks: stream_events_step.yml

    - name: "{{ run_prefix }} Check stop file"
      ansible.builtin.stat:
        path: "{{ workload_runner_workdir }}/STOP"
      register: workload_runner_stop_file

    - name: "{{ run_prefix }} Force stop LocalRunner if still running"
      ansible.builtin.shell:
        cmd: |
          set -euo pipefail
          pid_file="{{ workload_runner_workdir }}/lb_localrunner.pid"
          if [ -f "$pid_file" ]; then
            pid="$(cat "$pid_file" || true)"
            if [ -n "$pid" ]; then
              kill "$pid" || true
            fi
          fi
      args:
        executable: /bin/bash
      when:
        - workload_runner_stop_file.stat.exists
      failed_when: false
      changed_when: false

    - name: "{{ run_prefix }} Load LocalRunner status"
      ansible.builtin.slurp:
        src: "{{ workload_runner_workdir }}/lb_localrunner.status.json"
      register: workload_runner_status_raw
      failed_when: false
      changed_when: false

    - name: "{{ run_prefix }} Set LocalRunner result"
      ansible.builtin.set_fact:
        workload_runner_rep_result: >-
          {{
            (workload_runner_status_raw.content | b64decode | from_json)
            if workload_runner_status_raw is defined and workload_runner_status_raw.content is defined
            else {'rc': 1}
          }}

    - name: "{{ run_prefix }} Ensure LocalRunner finished"
      ansible.builtin.assert:
        that:
          - workload_runner_rep_result.rc is defined
        fail_msg: "LocalRunner status missing."

    - name: "{{ run_prefix }} Fail on LocalRunner error"
      ansible.builtin.assert:
        that:
          - workload_runner_rep_result.rc | default(0) == 0
        fail_msg: >-
          LocalRunner failed (rc={{ workload_runner_rep_result.rc | default('unknown') }}).

    - name: "{{ run_prefix }} Collect workload artifacts for repetition"
      ansible.builtin.include_tasks: collect_workload.yml

    - name: Emit completion event for repetition
      ansible.builtin.debug:
        msg: >-
          LB_EVENT {{
            {
              "run_id": run_id | default(""),
              "host": inventory_hostname,
              "workload": workload_runner_current_workload,
              "repetition": workload_runner_current_rep,
              "total_repetitions": workload_runner_total_reps,
              "status": "done"
            } | to_json
          }}
      when: workload_runner_rep_result.rc | default(1) == 0

    - name: "{{ run_prefix }} Cooldown between repetitions (pure, collectors stopped)"
      ansible.builtin.wait_for:
        timeout: "{{ workload_runner_config_rendered.cooldown_seconds | default(0) | int }}"
      when:
        - (workload_runner_config_rendered.cooldown_seconds | default(0) | int) > 0
        - workload_runner_reps is defined
        - workload_runner_current_rep != (workload_runner_reps | last)

  rescue:
    - name: "{{ run_prefix }} Emit failure event for repetition"
      ansible.builtin.debug:
        msg: >-
          LB_EVENT {{
            {
              "run_id": run_id | default(""),
              "host": inventory_hostname,
              "workload": workload_runner_current_workload,
              "repetition": workload_runner_current_rep,
              "total_repetitions": workload_runner_total_reps,
              "status": "failed",
              "message": (workload_runner_rep_result.stderr | default(workload_runner_rep_result.stdout | default(''))) | string
            } | to_json
          }}
    - name: "{{ run_prefix }} Collect workload artifacts for failed repetition"
      ansible.builtin.include_tasks: collect_workload.yml
      vars:
        workload_runner_collect_ignore_errors: true
    - name: Fail workload repetition
      ansible.builtin.fail:
        msg: >-
          Workload {{ workload_runner_current_workload }} repetition {{ workload_runner_current_rep }} failed (rc={{ workload_runner_rep_result.rc | default('unknown') }})
