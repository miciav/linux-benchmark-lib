# Recursive polling step - calls itself until workload_runner_finished is true
# This is the proper Ansible pattern for "poll until done"

- name: "Poll LB_EVENT stream"
  ansible.builtin.shell:
    cmd: |
      set -euo pipefail
      python3 - <<'PY'
      import json
      import os
      import sys
      import time

      log_path = "{{ workload_runner_output_dir | default('/tmp') }}/lb_events.stream.log"
      offset_path = "{{ workload_runner_output_dir | default('/tmp') }}/lb_events.offset"
      status_path = "{{ workload_runner_workdir }}/lb_localrunner.status.json"
      pid_path = "{{ workload_runner_workdir }}/lb_localrunner.pid"
      workload = "{{ workload_runner_current_workload }}"
      rep = int("{{ workload_runner_current_rep }}")
      poll_timeout = int("{{ workload_runner_poll_timeout_seconds | default(7200) }}")
      start_time_path = "{{ workload_runner_workdir }}/lb_poll_start.time"

      # Track polling start time
      poll_start = time.time()
      if os.path.exists(start_time_path):
          try:
              with open(start_time_path, "r") as f:
                  poll_start = float(f.read().strip())
          except Exception:
              pass
      else:
          with open(start_time_path, "w") as f:
              f.write(str(poll_start))

      offset = 0
      try:
          if os.path.exists(offset_path):
              with open(offset_path, "r") as f:
                  offset = int(f.read().strip() or 0)
      except Exception:
          offset = 0

      def is_running(pid):
          try:
              os.kill(int(pid), 0)
              return True
          except Exception:
              return False

      crashed = False
      if os.path.exists(pid_path) and not os.path.exists(status_path):
          try:
              with open(pid_path, "r") as f:
                  pid = f.read().strip()
              if not is_running(pid):
                  crashed = True
          except Exception:
              pass

      timed_out = (time.time() - poll_start) > poll_timeout
      finished = os.path.exists(status_path) or crashed or timed_out

      events = []
      new_offset = offset
      if os.path.exists(log_path):
          with open(log_path, "rb") as f:
              f.seek(offset)
              while True:
                  pos = f.tell()
                  line = f.readline()
                  if not line or not line.endswith(b"\n"):
                      new_offset = pos
                      break
                  try:
                      text = line.decode("utf-8").strip()
                      if "LB_EVENT" in text:
                          events.append(text)
                  except Exception:
                      pass
          with open(offset_path, "w") as f:
              f.write(str(new_offset))

      done = False
      for ev_text in events:
          try:
              data = json.loads(ev_text.split("LB_EVENT", 1)[1].strip())
              if data.get("workload") == workload and int(data.get("repetition", 0)) == rep:
                  if data.get("status") in ("done", "failed", "stopped"):
                      done = True
          except Exception:
              pass

      result = {
          "events": events,
          "done": finished or done,
          "status": "DONE" if (finished or done) else "CONTINUE"
      }
      print(json.dumps(result))
      PY
  args:
    executable: /bin/bash
  register: poll_res
  changed_when: false

- name: "Emit captured events"
  ansible.builtin.debug:
    msg: "{{ item }}"
  loop: "{{ (poll_res.stdout | from_json).events }}"
  when:
    - poll_res.stdout is defined
    - (poll_res.stdout | from_json).events | length > 0

- name: "Update finished status"
  ansible.builtin.set_fact:
    workload_runner_finished: "{{ (poll_res.stdout | from_json).done | bool }}"
  when: poll_res.stdout is defined

- name: "Clean up polling state"
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - "{{ workload_runner_workdir }}/lb_poll_start.time"
  when: workload_runner_finished | default(false)

- name: "Wait before next poll"
  ansible.builtin.wait_for:
    timeout: "{{ workload_runner_poll_delay | default(30) | int }}"
  when: not workload_runner_finished | default(false)

- name: "Continue polling (recursive)"
  ansible.builtin.include_tasks: stream_events_step.yml
  when: not workload_runner_finished | default(false)
